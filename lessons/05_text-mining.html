<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Text Mining - erste Schritte</title>
    <meta charset="utf-8" />
    <meta name="author" content="Andreas Blaette" />
    <link href="05_text-mining_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="05_text-mining_files/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="05_text-mining_files/remark-css-0.0.1/robot-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/polminify.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Text Mining - erste Schritte
### Andreas Blaette
### 4. Juni 2020

---

  
# Webscraping-Szenarien

Dieser Foliensatz vermittelt elementare Grundlagen zu folgenden Szenarien:

- direktes Laden von Daten von Online-Speicherorten
- Extraktion von Daten (Tabellen, Text) aus html-Dokumenten
- Download und Verarbeitung von pdf-Dokumenten

Schwieriger wird es, wenn Web-Seiten dynamisch aus Datenbanken generiert werden. Dann ist meist eine Fernsteuerung eines Browsers erforderlich, z.B. mit dem [Selenium WebDriver](https://www.selenium.dev/documentation/en/webdriver/) (vgl. R-Paket [RSelenium](https://cran.r-project.org/package=RSelenium)). Diese fortgeschrittene Technik wird in diesem Foliensatz nicht behandelt.

---

# Direkter Datenimport von Online-Speicherorten I

- Durch die Entwicklung hin zu Open Governmemt bzw. Open Data werden immer mehr Datensätze online zur Verfügung gestellt. Zum Teil sind dies Datenformate, die an eine bestimmte Software gebunden sind (z.B. Excel). Die Regel sind jedoch Datenaustauschformate wie [csv](https://de.wikipedia.org/wiki/CSV_%28Dateiformat%29) und [json](https://de.wikipedia.org/wiki/JavaScript_Object_Notation).

- *Beispiel 1*: Die Stadt Duisburg stellt über ein **Open Data**-Portal etliche interessante Datensätze zur Verfügung. Wir interessieren uns für eine Tabelle zu "Menschen mit Migrationshintergrund", welche die entsprechende Anteile nach Ortsteilen aufschlüsselt.

- Etliche R-Funktionen erkennen, wenn bei einem Dateinamen eine URL angegeben wird und laden die Datei direkt "aus dem Netz". Mit `read.csv()` kann man die Datei direkt laden. 


```r
df &lt;- read.csv(
  file = "https://opendata-duisburg.de/sites/default/files/MHGo2018_2.csv",
  sep = ";"
)
```



- Beispiel 2: Bundestagswahlergebnisse 2017


```r
btw17_url &lt;- "https://www.bundeswahlleiter.de/dam/jcr/72f186bb-aa56-47d3-b24c-6a46f5de22d0/btw17_kerg.csv"
btw17_local &lt;- tempfile()
download.file(url = btw17_url, destfile = btw17_local)
btw17_aux &lt;- scan(file = btw17_local, what = character(), sep = "\n")
df &lt;- read.csv(file = btw17_local, sep = ";", skip = 5)
```


---

# Verarbeitung von html-Dokumenten

- Grundsätzlich werden html-Dokumente wie xml-Dokumente verarbeitet. State-of-the-Art ist
  - die Repräsentation dre Datenstrukturen eines html-Dokuments mit dem xml2-Pakt; 
  - für die html-spezifische Datenextraktion wird das rvest-Paket verwendet.

- direktes Einlesen von Tabellen

- Beispiel: Extraktion einer Tabelle zu MdBs aus Wikipedia-Seite


```r
library(rvest)
```

```
## Loading required package: xml2
```

```r
library(xml2)

wikipedia_url &lt;- "https://de.wikipedia.org/wiki/Liste_der_Mitglieder_des_Deutschen_Bundestages_%2816._Wahlperiode%29"
page &lt;- xml2::read_html(wikipedia_url)
tables &lt;- rvest::html_nodes(page, "table")
tab &lt;- rvest::html_table(tables[[2]])
```

---

# Ergebnis der Daten-Extraktion


```r
head(tab[,1:3])
```

```
##   Mitglied des Bundestages geb. Partei
## 1           Jens Ackermann 1975    FDP
## 2              Ulrich Adam 1950    CDU
## 3             Karl Addicks 1950    FDP
## 4        Christian Ahrendt 1963    FDP
## 5              Ilse Aigner 1964    CSU
## 6               Lale Akgün 1953    SPD
```

Wir können beispielsweise das Durchschnittsalter beim Zusammentritt des Bundestags berechnen ...


```r
mean(2005 - tab[,2])
```

```
## [1] 49.33385
```

---

# Navigation im XML

- Um Text aus html-Dokumenten zu extrahieren, wird die hierarchische Baumstruktur des html-Dokuments mit Xpath-Ausdrücken abgefragt. 

- Ein typisches Szenario ist die Extraktion von Text aus einem Archiv von Pressemitteilungen (z.B. des [Bundespresse- und Informationsamts](https://de.wikipedia.org/wiki/Liste_der_Mitglieder_des_Deutschen_Bundestages_%2816._Wahlperiode%29))


```r
pm &lt;- "http://www.bundesregierung.de/Content/DE/Pressemitteilungen/BPA/2015/07/2015-07-09-bkm-kulturelle-bildung.html"
page &lt;- xml2::read_html(pm)
```


```r
paragraph_nodes &lt;- rvest::html_nodes(page, xpath = "//p") # Identifikation aller Absätze
paragraphs &lt;- sapply(paragraph_nodes, html_text) # Extraktion des Texts aus den Absätzeen
paragaphs &lt;- paragraphs[nchar(paragraphs) &gt; 0L] # Absätze ohne Text fallen lassen
paragaphs[1]
```

```
## [1] "Staatsministerin Monika Grütters (BKM) hat Spitzenorganisationen, Stiftungen und weitere Multiplikatoren eingeladen, ihre Vorschläge für den BKM-Preis Kulturelle Bildung 2016 einzureichen."
```

- XPath

---

# pdf-Dokumente: Tabellen extrahieren


```rm
url_ltw &lt;- "https://www.bundeswahlleiter.de/dam/jcr/a333e523-0717-42ad-a772-d5ad7e7e97cc/ltw_erg_gesamt.pdf"
ltw_local &lt;- tempfile()
pdf_local &lt;- download.file(url = url_ltw, destfile = ltw_local)
```



```r
library(tabulizer)
tabulizer::extract_tables(file = ltw_local, pages = 74)
```

---

# pdf-Dokumente: Text extrahieren


```r
cdu_btw2017 &lt;- "https://www.cdu.de/system/tdf/media/dokumente/170703regierungsprogramm2017.pdf?file=1"
cdu_btw2017_local &lt;- tempfile()
download.file(url = cdu_btw2017, destfile = cdu_btw2017_local)
```


```r
library(pdftools)
pdftools::pdf_info(cdu_btw2017_local)
txt &lt;- pdftools::pdf_text(cdu_btw2017_local)
```

---

# Reguläre Ausdrücke

| Ausdruck | Beschreibung |
|:-------:| --------------|
| .       |Ein Punkt (".") steht für ein beliebiges Zeichen |
| \\d | "digit" (Ziffer), d.h. 0 bis 9 |
| \\s | "whitespace" - Leerzeichen | 
| \\w | Buchstaben (keine Ziffern oder Leerzeichen) | 
---

# Quantoren

| Ausdruck | Beschreibung |
|:-------:| --------------|
|?|Der voranstehende Ausdruck kommt kein- oder einmal vor.|
|+|Der voranstehende Ausdruck tritt einmal oder mehrfach auf. |
|*|Der voranstehende Ausdruck tritt keinmal oder beliebig oft auf.|
|{n}|Der voranstehende Ausdruck tritt exakt n-fach auf.|
|{min,}| Der voranstehende Ausdruck tritt mindestens min-fach auf.|
|{min,max}|Der voranstehende Ausdruck tritt mindestens min-fach und maximal max-fach auf.|
|{0,max}| Der voranstehende Ausdruck darf maximal max-fach vorkommen.|

---

#  Rückwärts-Referenzen


---

# gsub


```r
txt2 &lt;- gsub("\\s{6,}\\d+", "", txt)
txt3 &lt;- gsub("\\n", " ", txt2)
txt4 &lt;- gsub("\\s+", " ", txt3)# große Lücken weg
txt5 &lt;- gsub("", " ", txt4) # Kästchen weg
txt6 &lt;- gsub("-\\s+(?!und)", "", txt5, perl = TRUE) # Bundestriche weg
```

---

# strsplit


```r
word_list &lt;- strsplit(x = txt6, split = "\\s")
words &lt;- unlist(word_list)
```


```r
words_cleaned &lt;- gsub("[,:\\.!?]", "", words)
words_cleaned &lt;- tolower(words_cleaned)
words_cleaned &lt;- words_cleaned[!words_cleaned %in% tm::stopwords("de")]
words_count &lt;- table(words_cleaned)
words_count_sorted &lt;- words_count[order(words_count, decreasing = TRUE)]
```

---
  
# Wortwolke


```r
library(wordcloud)

wordcloud(
  words = names(words_count_sorted)[1:50],
  freq = unname(words_count_sorted)[1:50]
)
```


---

# Übungsaufgaben 

Säubern Sie das Wahlprogramm von 
- SPD
- Bündnis 90/Die Grünen 
- FDP 
- Die LINKE
- AfD

... und erstellen Sie eine Wortwolke mit den häufigsten Worten.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
